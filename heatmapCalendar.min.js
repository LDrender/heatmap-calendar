var heatmapCalendar=(function(){'use strict';class Options {
    constructor() {
        // Default options
        Options.prototype.config = {
            // Style (light or dark)
            style: 'dark',

            // Size of the cell 
            cellSize: 20,

            //Selector string for the calendar container to append the calendar to
            container: '#heatmap-cal',

            //The number of months to display (default & max: 12)
            monthsDisplay: 12,

            //The number of days to display per column
            days: 7,

            //The month to start the calendar on (12 = current, 0 = January, 1 = February, etc.)
            month: 12,

            //The current date to display the calendar from
            currentDate: new Date().toISOString().slice(0, 10),

            //The display mode to use ('year', 'month', 'day', 'custom', 'auto')
            // 'auto' will use the current date. Tips : set the 'monthsDisplay' option to 12
            // 'year' will start on the first day of the year. Tips : this mods will display 12 months necessarily
            // 'month' will start on the month specified in the 'month' option. Tips : this mods will display 1 month necessarily
            displayMode: 'auto',

            // =================
            //  = Data Option =
            // =================

            //The data to use for the calendar {object}
            data: [],

            // ====================
            //  = Display Option =
            // ====================

            //Title to display above the calendar
            title: 'Calendar Heatmap',

            toolTip: {
                show: true,
                text: "Heat value",
                textPostion: 'after',
                separator: '-',
            },

            //Legend to display below the calendar
            legend: {
                show: true,
                // Align the legend to the left, right or center
                align: "right",
                minLabel: "less",
                maxLabel: "more",

                // ToolTip ('auto', 'hidden' or 'fixed' )
                // 'auto' will use the maximum heat value and other values will be calculated
                // 'hidden' will hide the heat value
                // 'fixed' will use the fixed value of the 'legend.value' array option
                toolTip: "auto",
                toolTip_default: [0, 1, 2, 3, 4],
                toolTip_value: [0, 1, 2, 3, 4],
            },


            // ==============
            //  = Function =
            // ==============

            // Get the options
            getOptions: this.getOptions,

            // Calculate tooltip values
            calculateToolTip: this.calculateToolTip,

            // Calcule if year is bissextile
            bissextile: this.bissextile,

            // getDateFrom function
            getDateFrom: this.getDateFrom,

            // getDaysInMonth function
            getDaysInMonth: this.getDaysInMonth,

            // calculateDays function
            calculateDays: this.calculateDays,

        };
    }

    // set the options

    /**
     * Set the options
     * @param {Object} config The options to set
     * @return {boolean} Whether the options have been changed
     */
    setOptions(options) {
        let changed = false;
        for (let key in options) {
            // Check if the option is a object and key is not 'data'
            if (typeof options[key] === 'object' && key !== 'data') {
                for (let subKey in options[key]) {
                    changed = this.setSubOption(key, subKey, options[key][subKey]) || changed;
                }
            }
            else {
                if (this.setOption(key, options[key])) {
                    changed = true;
                }
            }
        }
        return changed;
    };

    /**
     * Set a new value for an option, only if unchanged
     * @param {string} key   Name of the option
     * @param {any} value Value of the option
     * @return {boolean} Whether the option have been changed
     */
    setOption(key, value) {
        if (this.config[key] == value) {
            return false;
        }

        this.config[key] = typeof value === typeof this.config[key] ? value : this.config[key];
        return true;
    };

    /**
     * Set a new value for an sub option, only if unchanged
     * @param {string} key   Name of the option
     * @param {string} subKey   Name of the sub option
     * @param {any} value Value of the option
     * @return {boolean} Whether the option have been changed
     */
    setSubOption(key, subKey, value) {
        if (this.config[key][subKey] == value) {
            return false;
        }

        this.config[key][subKey] = typeof value === typeof this.config[key][subKey] ? value : this.config[key][subKey];
        return true;
    }

    /**
     * Get the options
     * @return {Object} The options
     */
    getOptions() {
        return this.config;
    }

    /**
     * Calculate tooltip values
     * @param {Object} data The data to use for the tooltip
     * @return {Array} The tooltip values
     */
    calculateToolTip(data) {
        let values = [];
        let max = 0;

        // Get the maximum value
        for (let i = 0; i < data.length; i++) {
            let value = parseInt(data[i].value);
            if (value > max) {
                max = value;
            }
        }

        // Calculate the tooltip values
        if (this.config.legend.toolTip === 'auto') {
            if (max >= 5) {
                for (let i = 0; i < this.config.legend.toolTip_value.length; i++) {
                    values.push(Math.round(max * this.config.legend.toolTip_value[i] / 5));
                }
                values[1] = 1;
            } else {
                values = this.config.legend.toolTip_default;
            }
        }
        else if (this.config.legend.toolTip === 'fixed') {
            values = this.config.legend.toolTip_value;
        }

        return values;
    }

    // Calcule if year is bissextile
    bissextile() {
        const year = new Date().getFullYear();

        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
            return 366;
        }

        return 365;
    };

    // getDateFrom function
    getDateFrom() {
        if (this.displayMode === 'year') {
            return new Date(new Date().getFullYear(), 0, 0);
        }
        else if (this.displayMode === 'month') {
            let month = this.month === 12 ? new Date().getMonth() : this.month;
            return new Date(new Date().getFullYear(), month, 1);
        }

        if (this.monthsDisplay === 12) {
            return new Date(new Date().setDate(new Date().getDate() - (this.bissextile())));
        }
        else {
            let month = this.month === 12 ? new Date().getMonth() : this.month;
            let date = new Date(new Date().getFullYear(), month, 0);
            let year = date.getFullYear();

            if (this.month === 12) {
                month = month - (this.monthsDisplay - 1);

                if (month < 0) {
                    month = 11 + month;
                    year = year - 1;
                }

                date = new Date(year, month, 0);
            }

            return date;
        }
    }

    // displayMode function
    calculateDays() {
        let nbrDays = 0;
        let startDate = null;

        if (this.displayMode === 'auto') {
            if (this.monthsDisplay === 12) {
                nbrDays = this.bissextile();
                startDate = this.getDateFrom('year');
            }
            else {
                startDate = this.getDateFrom();
                nbrDays = this.getDaysInMonth(startDate);
            }
        }
        else if (this.displayMode === 'year') {
            nbrDays = this.bissextile();
            startDate = this.getDateFrom('year');
        }
        else if (this.displayMode === 'month') {
            startDate = this.getDateFrom('month');
            nbrDays = new Date(new Date().getFullYear(), startDate.getMonth() + 1, 0).getDate();
        }
        else {
            nbrDays = this.bissextile();
            startDate = this.getDateFrom('year');
        }

        return {
            nbrDays: nbrDays,
            startDate: startDate
        }
    }

    getDaysInMonth(startMouth) {
        let nbrDays = 0;
        let month = startMouth.getMonth() + 1;
        new Date(startMouth).getFullYear();

        for (let i = 0; i < this.monthsDisplay; i++) {

            if (month > 11) {
                month = 0;
            }
            nbrDays += new Date(new Date().getFullYear(), month, 0).getDate();

            month++;
        }

        return nbrDays;
    }
}/**
 * Calendar class extends HeatmapCalendar
 */

class Calendar extends Options {



    // Init calendar options
    initOptions() {

    }

    // Init calendar data
    initData() {
        
    }

    // Draw the calendar heatmap
    drawContainer() {

        // Create container for the calendar heatmap in the source container
        const calendar = document.createElement('div');
        calendar.classList.add('calendar-heatmap');
        if(super.config.style === 'dark') {
            calendar.classList.add('dark');
        }
        calendar.style.cssText += `--cell-size: ${super.config.cellSize}px`;
        document.querySelector(super.config.container).appendChild(calendar);

        // Create the calendar heatmap title
        if(super.config.title) {
            const title = document.createElement('h2');
            title.classList.add('calendar-heatmap-title');
            title.textContent = super.config.title;
            calendar.appendChild(title);
        }

        // Create the calendar date container
        const dateContainer = document.createElement('div');
        dateContainer.classList.add('calendar-heatmap-date-container');
        calendar.appendChild(dateContainer);

        // Create the calendar heatmap legend
        if(super.config.legend.show) {
            const legend = document.createElement('div');
            legend.classList.add('calendar-heatmap-legend');
            legend.classList.add(`calendar-heatmap-legend-position-${super.config.legend.align}`);
            calendar.appendChild(legend);
            this.drawLegende(legend);
        }

        // Draw the calendar heatmap
        this.drawCalendarData(dateContainer);
    }
        
    drawCalendarData(container) {
        
        // Draw the columns calendar heatmap
        const calcDay = super.config.calculateDays();
        const level = super.config.legend.toolTip_value;
        let day = 0;


        while(day <= calcDay.nbrDays){

            const column = document.createElement('div');
            column.classList.add('calendar-heatmap-column');

            for(let i = 0; i < super.config.days; i++) {

                day++;
                if(day > calcDay.nbrDays) {
                    break;
                }

                const newDay = document.createElement('span');
                newDay.classList.add('calendar-heatmap-day');

                // Set date
                const date = new Date(calcDay.startDate.setDate(calcDay.startDate.getDate() + 1));
                const formatDate = date.toLocaleDateString().slice(0, 10);
                newDay.dataset.date = formatDate;

                // Check if the last day or current day
                if(date.toISOString().slice(0, 10) === super.config.currentDate) {
                    newDay.classList.add('current');
                }

                // Check if the date exists in a variable of the object and get the corresponding value to give it as dataset else set the value to 0
                if(super.config.data) {
                    super.config.data.forEach((item) => {
                        if(item.date === date.toISOString().slice(0, 10)) {
                            newDay.dataset.value = item.value;
                        }
                        else if(!newDay.dataset.value) {
                            newDay.dataset.value = 0;
                        }
                    });
                }

                // Apply dataset level
                if(newDay.dataset.value >= level[0] && newDay.dataset.value < level[1]) {
                    newDay.dataset.level = 0;
                }
                else if(newDay.dataset.value >= level[1] && newDay.dataset.value < level[2]) {
                    newDay.dataset.level = 1;
                }
                else if(newDay.dataset.value >= level[2] && newDay.dataset.value < level[3]) {
                    newDay.dataset.level = 2;
                }
                else if(newDay.dataset.value >= level[3] && newDay.dataset.value < level[4]) {
                    newDay.dataset.level = 3;
                }
                else if(newDay.dataset.value >= level[4]) {
                    newDay.dataset.level = 4;
                }

                if(super.config.toolTip.show) {
                    if(super.config.toolTip.textPostion === 'after') {
                        newDay.dataset.tooltip = `${newDay.dataset.value} ${super.config.toolTip.text} ${super.config.toolTip.separator} ${formatDate}`;
                    }
                    else {
                        newDay.dataset.tooltip = `${super.config.toolTip.text} ${newDay.dataset.value} ${super.config.toolTip.separator} ${formatDate}`;
                    }
                }
                
                column.appendChild(newDay);
                
            }

            container.appendChild(column);
        }
        
    }

    drawLegende(container) {
        // Create the calendar heatmap legend min label
        if(super.config.legend.minLabel) {
            const minLabel = document.createElement('span');
            minLabel.classList.add('calendar-heatmap-legend-min-label');
            minLabel.textContent = super.config.legend.minLabel;
            container.appendChild(minLabel);
        }

        const legendTooltip_Value = super.config.legend.toolTip_value;
        legendTooltip_Value.forEach((value, index) => {
            // Create the calendar heatmap legend color box
            const colorBox = document.createElement('span');
            colorBox.classList.add('calendar-heatmap-day');
            colorBox.dataset.level = index;

            if(super.config.legend.toolTip !== 'hidden') {
                colorBox.dataset.tooltip = value;
            }

            container.appendChild(colorBox);
        });

        // Create the calendar heatmap legend max label
        if(super.config.legend.maxLabel) {
            const maxLabel = document.createElement('span');
            maxLabel.classList.add('calendar-heatmap-legend-max-label');
            maxLabel.textContent = super.config.legend.maxLabel;
            container.appendChild(maxLabel);
        }
    }

}/**
 * Calendar Heatmap
 * Global variables
 */
class HeatmapCalendar {
    constructor(options, data) {
        this.options = new Options(options);
        this.calendar = new Calendar();

        // Init the calendar heatmap
        this.init(options, data);
    }

    init(options, data) {
        // Set the options
        if(options) {
            this.options.setOptions(options);
        }

        // Set the data
        this.options.config.data = typeof data === 'object' ? data : this.options.config.data;

        // Edit tooltip values if needed
        if(this.options.config.legend.toolTip === "auto" && data) {
            this.options.config.legend.toolTip_value = this.options.calculateToolTip(this.options.config.data);
        }

        // Create the calendar heatmap
        this.calendar.drawContainer();

        return true;
    }
}return HeatmapCalendar;})();