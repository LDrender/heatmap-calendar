var heatmapCalendar = (function () {
    'use strict';

    class Options {
        constructor() {
            // Default options
            Options.prototype.config = {

                style: {
                    // Defines the style of the heatmap (light or dark)
                    type: 'dark',
                    // Defines the size of the heatmap cells
                    cellSize: 20,
                    // Defines the radius of the rounded cells
                    cellRadius: 3,
                    // Defines the spacing between cells
                    cellGap: 4,
                    // Defines the color of cells for level 0
                    cellColor_level_0: 'rgba(110, 118, 129, 25%)',
                    // Defines the color of cells for level 1
                    cellColor_level_1: '#0e4429',
                    // Defines the color of cells for level 2
                    cellColor_level_2: '#006d32',
                    // Defines the color of cells for level 3
                    cellColor_level_3: '#26a641',
                    // Defines the color of cells for level 4
                    cellColor_level_4: '#39d353',
                },

                // Select language ('en-US', 'fr-FR', ...)
                language: 'en-US',

                //Selector string for the calendar container to append the calendar to
                container: '#heatmap-cal',

                //The number of months to display (default & max: 12)
                nbrDisplayMonth: 12,

                //The number of days to display per column
                days: 7,

                //The month to start the calendar on (12 = current, 0 = January, 1 = February, etc.)
                month: 12,

                //The current date to display the calendar from
                currentDate: new Date().toLocaleDateString('en-US').slice(0, 10),

                //The display mode to use ('year', 'month', 'day', 'custom', 'auto')
                // 'auto' will use the current date. Tips : set the 'nbrDisplayMonth' option to 12
                // 'year' will start on the first day of the year. Tips : this mods will display 12 months necessarily
                // 'month' will start on the month specified in the 'month' option. Tips : this mods will display 1 month necessarily
                display: 'auto',

                // ====================
                //  = Display Option =
                // ====================

                //Title to display above the calendar
                title: 'Calendar Heatmap',

                toolTip: {
                    show: true,
                    text: "Heat value",
                    textPostion: 'after',
                    separator: '-',
                },

                //Legend to display below the calendar
                legend: {
                    show: true,
                    // Align the legend to the left, right or center
                    align: "right",
                    minLabel: "less",
                    maxLabel: "more",

                    // ToolTip ('auto', 'hidden' or 'fixed' )
                    // 'auto' will use the maximum heat value and other values will be calculated
                    // 'hidden' will hide the heat value
                    // 'fixed' will use the fixed value of the 'legend.value' array option
                    toolTip: "auto",
                    toolTip_default: [0, 1, 2, 3, 4],
                    toolTip_value: [0, 1, 2, 3, 4],
                },


                // ==============
                //  = Function =
                // ==============

                // Get the options
                getOptions: this.getOptions,

                // Calculate tooltip values
                calculateToolTip: this.calculateToolTip,

                // Calcule if year is bissextile
                bissextile: this.bissextile,

                // getDateFrom function
                calculateDateParameters: this.calculateDateParameters,
            };
        }

        // set the options

        /**
         * Set the options
         * @param {Object} config The options to set
         * @return {boolean} Whether the options have been changed
         */
        setOptions(options) {
            let changed = false;
            for (let key in options) {
                // Check if the option is a object and key is not 'data'
                if (typeof options[key] === 'object' && key !== 'data') {
                    for (let subKey in options[key]) {
                        changed = this.setSubOption(key, subKey, options[key][subKey]) || changed;
                    }
                }
                else {
                    if (this.setOption(key, options[key])) {
                        changed = true;
                    }
                }
            }
            return changed;
        };

        /**
         * Set a new value for an option, only if unchanged
         * @param {string} key   Name of the option
         * @param {any} value Value of the option
         * @return {boolean} Whether the option have been changed
         */
        setOption(key, value) {
            if (this.config[key] == value) {
                return false;
            }

            this.config[key] = typeof value === typeof this.config[key] ? value : this.config[key];
            return true;
        };

        /**
         * Set a new value for an sub option, only if unchanged
         * @param {string} key   Name of the option
         * @param {string} subKey   Name of the sub option
         * @param {any} value Value of the option
         * @return {boolean} Whether the option have been changed
         */
        setSubOption(key, subKey, value) {
            if (this.config[key][subKey] == value) {
                return false;
            }

            this.config[key][subKey] = typeof value === typeof this.config[key][subKey] ? value : this.config[key][subKey];
            return true;
        }

        /**
         * Get the options
         * @return {Object} The options
         */
        getOptions() {
            return this.config;
        }

        /**
         * Calculate tooltip values
         * @param {Object} data The data to use for the tooltip
         * @return {Array} The tooltip values
         */
        calculateToolTip(data) {
            let values = [];
            let max = 0;

            // Get the maximum value
            for (let i = 0; i < data.length; i++) {
                let value = parseInt(data[i].value);
                if (value > max) {
                    max = value;
                }
            }

            // Calculate the tooltip values
            if (this.config.legend.toolTip === 'auto') {
                if (max >= 5) {
                    for (let i = 0; i < this.config.legend.toolTip_value.length; i++) {
                        values.push(Math.round(max * this.config.legend.toolTip_value[i] / 5));
                    }
                    values[1] = 1;
                } else {
                    values = this.config.legend.toolTip_default;
                }
            }
            else if (this.config.legend.toolTip === 'fixed') {
                values = this.config.legend.toolTip_value;
            }

            return values;
        }

        // Calcule if year is bissextile
        bissextile() {
            const year = new Date().getFullYear();

            if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
                return 366;
            }

            return 365;
        };

        // getDateFrom function
        calculateDateParameters() {
            let current = new Date();
            let month = this.month === 12 ? current.getMonth() : this.month;
            let year = current.getFullYear();
            let date = null;
            let nbrDays = 0;

            if (this.display === 'year') {
                date = new Date(year, 0, 0);
                nbrDays = this.bissextile();
            }
            else if (this.nbrDisplayMonth === 12) {
                if(this.display === 'month') {
                    date = new Date(year, month, 0);
                    nbrDays = new Date(year, month + 1, 0).getDate();
                }
                else {
                    date = new Date(new Date().setDate(current.getDate() - (this.bissextile())));
                    nbrDays = this.bissextile();
                }
            }
            else {
                if (this.display === 'month') {
                    current = new Date(current.setDate(new Date(year, month + 1, 0).getDate()));
                }

                let monthsAgo = current.getMonth() - (this.nbrDisplayMonth - 1);
                let yearAgo = current.getFullYear();
                if (monthsAgo < 0) {
                    yearAgo--;
                    monthsAgo = 11 + monthsAgo;
                }

                let dateAgo = new Date(yearAgo, monthsAgo, 0);
                if(this.display === 'month') {
                    month = dateAgo.getMonth() + 2;
                }
                else {
                    month = dateAgo.getMonth() + 1;
                }
                year = dateAgo.getFullYear();

                for (let i = 0; i < this.nbrDisplayMonth; i++) {

                    if (month > 11) {
                        month = 0;
                        year++;
                    }
                    nbrDays += new Date(new Date().getFullYear(), month, 0).getDate();
                    console.log(new Date(new Date().getFullYear(), month, 0), new Date(new Date().getFullYear(), month, 0).getDate());
        
                    month++;
                }
                date = new Date(current.setDate(current.getDate() - nbrDays));
            }

            return {
                nbrDays: nbrDays,
                startDate: date
            };
        }
    }

    /**
     * Calendar class extends HeatmapCalendar
     */

    class Calendar extends Options {

        // Draw the calendar heatmap
        drawContainer() {

            // Create container for the calendar heatmap in the source container
            const calendar = document.createElement('div');
            calendar.classList.add('calendar-heatmap');
            if(super.config.style.type === 'dark') {
                calendar.classList.add('dark');
            }
            
            calendar.style.cssText += `--cell-size: ${super.config.style.cellSize}px`;
            calendar.style.cssText += `--cell-radius: ${super.config.style.cellRadius}px`;
            calendar.style.cssText += `--cell-gap: ${super.config.style.cellGap}px`;
            calendar.style.cssText += `--color-data-level-0: ${super.config.style.cellColor_level_0}`;
            calendar.style.cssText += `--color-data-level-1: ${super.config.style.cellColor_level_1}`;
            calendar.style.cssText += `--color-data-level-2: ${super.config.style.cellColor_level_2}`;
            calendar.style.cssText += `--color-data-level-3: ${super.config.style.cellColor_level_3}`;
            calendar.style.cssText += `--color-data-level-4: ${super.config.style.cellColor_level_4}`;
            
            document.querySelector(super.config.container).appendChild(calendar);

            // Create the calendar heatmap title
            if(super.config.title) {
                const title = document.createElement('h2');
                title.classList.add('calendar-heatmap-title');
                title.textContent = super.config.title;
                calendar.appendChild(title);
            }

            const calendarMonth = document.createElement('div');
            calendarMonth.classList.add('calendar-heatmap-month');
            calendar.appendChild(calendarMonth);

            // Create the calendar date container
            const dateContainer = document.createElement('div');
            dateContainer.classList.add('calendar-heatmap-date-container');
            calendar.appendChild(dateContainer);

            // Create the calendar heatmap legend
            if(super.config.legend.show) {
                const legend = document.createElement('div');
                legend.classList.add('calendar-heatmap-legend');
                legend.classList.add(`calendar-heatmap-legend-position-${super.config.legend.align}`);
                calendar.appendChild(legend);
                this.drawLegende(legend);
            }

            // Draw the calendar heatmap
            this.drawCalendarData(dateContainer, calendarMonth);
        }
            
        drawCalendarData(container, monthContainer) {
            
            // Draw the columns calendar heatmap
            const calcDay = super.config.calculateDateParameters();
            const level = super.config.legend.toolTip_value;
            const firstDate = new Date(calcDay.startDate.setDate(calcDay.startDate.getDate()));
            let day = 0;

            while(day <= calcDay.nbrDays){

                const column = document.createElement('div');
                column.classList.add('calendar-heatmap-column');

                for(let i = 0; i < super.config.days; i++) {

                    day++;
                    if(day > calcDay.nbrDays) {
                        break;
                    }

                    const newDay = document.createElement('span');
                    newDay.classList.add('calendar-heatmap-day');

                    // Set date
                    const date = new Date(calcDay.startDate.setDate(calcDay.startDate.getDate() + 1));

                    const formatDate = date.toLocaleDateString().slice(0, 10);
                    newDay.dataset.date = formatDate;

                    // Check if the last day or current day
                    if(date.toLocaleDateString('en-US') === super.config.currentDate) {
                        newDay.classList.add('current');
                    }

                    // Check if the date exists in a variable of the object and get the corresponding value to give it as dataset else set the value to 0
                    if(super.config.data) {
                        super.config.data.forEach((item) => {
                            const tempDate = new Date(item.date);
                            if(tempDate.toLocaleDateString('en-US') === date.toLocaleDateString('en-US')) {
                                newDay.dataset.value = item.value;
                            }
                            else if(!newDay.dataset.value) {
                                newDay.dataset.value = 0;
                            }
                        });
                    }

                    // Apply dataset level
                    if(newDay.dataset.value >= level[0] && newDay.dataset.value < level[1]) {
                        newDay.dataset.level = 0;
                    }
                    else if(newDay.dataset.value >= level[1] && newDay.dataset.value < level[2]) {
                        newDay.dataset.level = 1;
                    }
                    else if(newDay.dataset.value >= level[2] && newDay.dataset.value < level[3]) {
                        newDay.dataset.level = 2;
                    }
                    else if(newDay.dataset.value >= level[3] && newDay.dataset.value < level[4]) {
                        newDay.dataset.level = 3;
                    }
                    else if(newDay.dataset.value >= level[4]) {
                        newDay.dataset.level = 4;
                    }

                    if(super.config.toolTip.show) {
                        if(super.config.toolTip.textPostion === 'after') {
                            newDay.dataset.tooltip = `${newDay.dataset.value} ${super.config.toolTip.text} ${super.config.toolTip.separator} ${formatDate}`;
                        }
                        else {
                            newDay.dataset.tooltip = `${super.config.toolTip.text} ${newDay.dataset.value} ${super.config.toolTip.separator} ${formatDate}`;
                        }
                    }
                    
                    column.appendChild(newDay);
                    
                }

                container.appendChild(column);
            }

            let firstDay = firstDate.getDate();
            let firstMonth = firstDate.getMonth();
            let displayMonth = super.config.nbrDisplayMonth;
            if(super.config.display === 'month') {
                displayMonth = displayMonth === 12 ? 1 : displayMonth;
            }
            else if (super.config.display === 'year') {
                displayMonth = 12;
            }
            
            // Set the next month if the first day is superior to 15
            if(firstDay > 15) {
                firstMonth++;
            }

            // Write the name of the month according to the number of nbrDisplayMonth
            for(let i = 0; i < displayMonth; i++) {
                const month = document.createElement('span');
                const monthDate = new Date(new Date().setMonth(firstMonth));
                month.classList.add('calendar-heatmap-month-name');
                month.textContent = monthDate.toLocaleDateString(super.config.language, { month: 'short' });
                monthContainer.appendChild(month);
                firstMonth++;
            }
                    
        }

        drawLegende(container) {
            // Create the calendar heatmap legend min label
            if(super.config.legend.minLabel) {
                const minLabel = document.createElement('span');
                minLabel.classList.add('calendar-heatmap-legend-min-label');
                minLabel.textContent = super.config.legend.minLabel;
                container.appendChild(minLabel);
            }

            const legendTooltip_Value = super.config.legend.toolTip_value;
            legendTooltip_Value.forEach((value, index) => {
                // Create the calendar heatmap legend color box
                const colorBox = document.createElement('span');
                colorBox.classList.add('calendar-heatmap-day');
                colorBox.dataset.level = index;

                if(super.config.legend.toolTip !== 'hidden') {
                    colorBox.dataset.tooltip = value;
                }

                container.appendChild(colorBox);
            });

            // Create the calendar heatmap legend max label
            if(super.config.legend.maxLabel) {
                const maxLabel = document.createElement('span');
                maxLabel.classList.add('calendar-heatmap-legend-max-label');
                maxLabel.textContent = super.config.legend.maxLabel;
                container.appendChild(maxLabel);
            }
        }

    }

    /**
     * Calendar Heatmap
     * Global variables
     */
    class HeatmapCalendar {
        constructor(options, data) {
            this.options = new Options(options);
            this.calendar = new Calendar();

            // Init the calendar heatmap
            this.init(options, data);
        }

        init(options, data) {
            // Set the options
            if(options) {
                this.options.setOptions(options);
            }

            // Set the data
            this.options.config.data = typeof data === 'object' ? data : this.options.config.data;

            // Edit tooltip values if needed
            if(this.options.config.legend.toolTip === "auto" && data) {
                this.options.config.legend.toolTip_value = this.options.calculateToolTip(this.options.config.data);
            }

            // Create the calendar heatmap
            this.calendar.drawContainer();

            return true;
        }
    }

    return HeatmapCalendar;

})();
